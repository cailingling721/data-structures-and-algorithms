---
title: 数据结构和算法-复杂度分析(2)
date: 2019-08-02 16:08:24
tags: 数据结构和算法 复杂度分析
---

本篇博客的主要内容就是四种时间复杂度以及一些分析复杂度的实例。

## 复杂度分析

### 最好和最坏时间复杂度

1. 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。
2. 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。

拿下面的查找函数find为例子，如果要查找的元素正好位于数组的第一个位置，那么时间复杂度就是O(1),如果要查找的元素正好位于最后一个，那么就是最坏时间复杂度O(n)。

<!-- more -->

### 平均时间复杂度

平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。那么如何计算平均时间复杂度呢？

因为要查找的变量x出现在数组中的位置可以有n+1种情况，最后这一种就代表要查找的元素不在此数组中。所以此时将每种情况下，查找元素需要遍历的元素个数累加即：1+2+3+...+n+n,然后除以n+1得到：((n+3)n)/(n+1),由此得到需要遍历元素个数的平均值。根据时间复杂度的大O计数法，可以省略系数、低阶和常量，所以就是O(n)。

``` java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

但是前面计算平均时间复杂度是有一定的问题的，因为没有把每种情况会出现的概率考虑进去。首先，要查找的元素要么在数组中，要么不在数组中，在和不在的概率都是1/2；另外要查找的元素出现在0-n-1这n个位置中的概率也是一样的，即为1/n。那么根据概率乘法，要查找的元素出现在0-n-1的概率就是1/2n。因此平均时间复杂度就变为了：

``` bash
1\*(1/2n) + 2\*(1/2n) + 3\*(1/2n) + ... + n\*(1/2n) + n \* 1/2 = (3n + 1)/4 = O(n)
```

用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。

### 均摊时间复杂度

均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

``` java
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
以上这段代码，是往数组中插入数据，最理想的情况就是数组中有空闲位置，此时插入到数组下标为count的位置就好，此时时间复杂度为O(1),最坏情况就是数组中没有空闲空间了，这时就需要做一次数组遍历求和，然后再将数据插入，此时是最坏时间复杂度O(n)。

此时如果去计算平均时间复杂度就是：插入数组的n个位置的时间复杂度为O(1),额外情况就是上面所说的O(n),而且这n+1种情况的发生概率一样。

``` bash
1\*(1/(n+1)) + 1\*(1/(n+1)) + 1\*(1/(n+1)) + ... + 1\*(1/(n+1)) + n\*(1/(n+1)) = O(1)
```

对比以上两个函数find()和insert()，对于find来说最优时间复杂度是O(1)，而对于insert()来说，大部分情况下时间复杂度都是O(1)。另外对于这里的insert()函数来说，并非一次操作，而是循环往复的操作，而且每一次O(n)的操作之后都会接着有n-1次O(1)的插入操作。所以就可以将耗时多的那次均摊到接下来的n-1次操作上。均摊下来，这一组连续操作的时间复杂度就是O(1)。这就是均摊时间复杂度。此种分析方法叫做摊还分析法。

均摊时间复杂度就是一种特殊的平均时间复杂度，而且二者的应用场景并不多。

### 一个分析实例

add()函数如下：
``` java
// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10];  // len并非确定量，只是初始值而已
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加一
   array[i] = element;
   ++i;
}

```

1. 最好情况时间复杂度为 O(1)
2. 最坏情况分析： 
	最坏情况代码执行的次数跟每次数组的长度有关
	第1次调用insert的执行的次数为 n ,
	第2次调用insert的执行的次数为 2n ,
	第3次调用insert的执行的次数为 2^2 * n 
	第k次调用insert的执行的次数为 2^(k-1) * n 
	最坏时间复杂度为 O(n)。
3. 平均情况分析
	当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0~len-1, len~(2len-1),....；
	插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1，
	最后求出加权平均时间复杂度为 1*p + 2*p+ ▪▪▪ + len*p + len * p = O(1) ; 
4. 均摊时间复杂度 O(1)
	均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)